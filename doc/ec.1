.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "EC" 1 "2022-12-27" "1.10" ""
.SH NAME
ec \- engineering calculator
.\" :Copyright: public domain
.
.\" :Manual group: Utilities
.
.SH SYNOPSIS
.sp
\fBec\fP [\fIoptions\fP] [\fIscripts\fP ...]
.SH OPTIONS
.INDENT 0.0
.TP
.B  \-i\fP,\fB  \-\-interactive
Open an interactive session.
.TP
.BI \-s \ <file>\fR,\fB \ \-\-startup \ <file>
Run commands from file to initialize calculator before
any script or interactive session is run, stack is
cleared after it is run.
.TP
.B  \-c\fP,\fB  \-\-nocolor
Do not use colors in the output.
.TP
.B  \-v\fP,\fB  \-\-verbose
Narrate the execution of any scripts.
.TP
.B  \-V\fP,\fB  \-\-version
Print the ec version information.
.TP
.B  \-h\fP,\fB  \-\-help
Print the usage and exit.
.UNINDENT
.SH DESCRIPTION
.sp
\fBec\fP is a stack\-based (RPN) engineering calculator with a text\-based user
interface that is intended to be used interactively.
.sp
If run with no arguments, an interactive session is started.  If arguments
are present, they are tested to see if they are filenames, and if so, the
files are opened and the contents are executed as a script.  If they are not
file names, then the arguments themselves are treated as scripts and
executed directly. The scripts are run in the order they are specified.  In
this case an interactive session would not normally be started, but if the
interactive option is specified, it would be started after all scripts have
been run.
.sp
The contents of \fI~/.ecrc\fP, \fI\&./.ecrc\fP, and the startup file will be run upon
startup if they exist, and then the stack is cleared.
.SH STACK
.sp
As you enter numbers they are pushed onto a stack.  The most recent member
of the stack is referred to as the \fIx\fP register and the second most recent
is the \fIy\fP register.  All other members of the stack are unnamed.  Operators
consume numbers off the stack to use as operands and then they push the
results back on the stack.  The operations are performed immediately and
there is no use of parentheses to group calculations.  Any intermediate
results are stored on the stack until needed.  For example,
.INDENT 0.0
.INDENT 3.5
.nf
4
6
+
.fi
.sp
.UNINDENT
.UNINDENT
.sp
In this case 4 gets pushed on to the stack first to become \fIx\fP\&. Then 6 gets
pushed on to the stack to become \fIx\fP, which makes 4 \fIy\fP\&. Finally, + pulls
both off the stack, sums them, and then pushes the result of 10 back onto
the stack.  The stack is left with only one number on it, 10.
.sp
After each line \fBec\fP responds by printing the value of the \fIx\fP register.
Thus the above example would actually look like this:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 4
\fB4\fP: 6
\fB6\fP: +
\fB10\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The benefit of the stack is that it allows you to easily store temporary
results while you perform your calculation. For example, to evaluate (34 \-
61)*(23 \- 56) you would use:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 34
\fB34\fP: 61
\fB61\fP: \-
\fB\-27\fP: 23
\fB23\fP: 56
\fB56\fP: \-
\fB\-33\fP: *
\fB891\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Notice that you entered the numbers as you saw them in the formula you were
evaluating, and there was no need to enter parentheses, however the
operators were rearranged in order to express the precedence of the
operations.
.sp
It is not necessary to type enter after each number or operator. You can
combine them onto one line and just type enter when you would like to see
the result:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 34 61 \- 23 56 \- *
\fB891\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Furthermore, it is not necessary to type a space between a number and most
operators. For example, the above could be entered as:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 34 61\- 23 56\- *
\fB891\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
You can print the entire stack using \fIstack\fP, and clear it using \fIclstack\fP\&.
For example,
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1 2 3 stack
.in +2
.in +2
 3
.in -2
\fIy\fP: 2
\fIx\fP: 1
.in -2
\fB3\fP: clstack
\fB0\fP: stack
\fB0\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.SH REAL NUMBERS
.sp
Numbers can be entered using normal integer, floating point, and scientific
notations. For example,
.INDENT 0.0
.INDENT 3.5
.nf
42
3.141592
5,439,749.97
2.998e8
13.80651e\-24
.fi
.sp
.UNINDENT
.UNINDENT
.sp
In addition, you can also use the normal SI scale factors to represent
either large or small numbers without using scientific notation.
.INDENT 0.0
.INDENT 3.5
.TS
center;
|l|l|.
_
T{
Y
T}	T{
1e24 (yotta)
T}
_
T{
Z
T}	T{
1e21 (zetta)
T}
_
T{
E
T}	T{
1e18 (exa)
T}
_
T{
P
T}	T{
1e15 (peta)
T}
_
T{
T
T}	T{
1e12 (terra)
T}
_
T{
G
T}	T{
1e9 (giga)
T}
_
T{
M
T}	T{
1e6 (mega)
T}
_
T{
k, K
T}	T{
1e3 (kilo)
T}
_
T{
_
T}	T{
unity (1)
T}
_
T{
m
T}	T{
1e\-3 (milli)
T}
_
T{
u
T}	T{
1e\-6 (micro)
T}
_
T{
n
T}	T{
1e\-9 (nano)
T}
_
T{
p
T}	T{
1e\-12 (pico)
T}
_
T{
f
T}	T{
1e\-15 (fempto)
T}
_
T{
a
T}	T{
1e\-18 (atto)
T}
_
T{
z
T}	T{
1e\-21 (zepto)
T}
_
T{
y
T}	T{
1e\-24 (yocto)
T}
_
.TE
.UNINDENT
.UNINDENT
.sp
For example, 10M represents 1e7 and 8.8p represents 8.8e\-12.
.sp
Optionally, numbers can be combined with simple units. For example,
.INDENT 0.0
.INDENT 3.5
.nf
10KHz
3.16pF
2.5_V
4.7e\-10F
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Both units and scale factors are optional, which causes a natural ambiguity
as to whether the first letter of a suffix is a scale factor or not. If the
first letter is a valid scale factor, then it is assume to be a scale
factor.  In this way, \(aq300K is treated as 300e3 rather than 300 Kelvin. If
you intend the units without a scale factor, add the unit scale factor: \(aq_\(aq.
Thus, use 300_K to enter 300 Kelvin.
.sp
In this case the units must be simple identifiers (must not contain special
characters). For complex units, such as \(dqrads/s\(dq, or for numbers that do not
have scale factors, it is possible to attach units to a number in the \fIx\fP
register by entering a quoted string.
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 6.626e\-34
\fB662.6e\-36\fP: \(dqJ\-s\(dq
\fB662.6e\-36 J\-s\fP: 50k \(dqV/V\(dq
\fB50 KV/V\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The dollar sign ($) is a special unit that is given before the number.
.INDENT 0.0
.INDENT 3.5
.nf
$100K
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Numbers my also contain commas as digit separators, which are ignored.
.INDENT 0.0
.INDENT 3.5
.nf
$200,000.00
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The dollar sign ($) is a special unit that is given before the number.
.sp
\fBec\fP takes a conservative approach to units. You can enter them and it
remembers them, but they do not survive any operation where the resulting
units would be in doubt.  In this way it displays units when it can, but
should never display incorrect or misleading units. For example:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 100MHz
\fB100 MHz\fP: 2pi*
\fB628.32M\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
You can display real numbers using one of four available formats, \fIfix\fP,
\fIsci\fP, \fIeng\fP, or \fIsi\fP\&. These display numbers using fixed point notation (a
fixed number of digits to the right of the decimal point), scientific
notation (a mantissa and an exponent), engineering notation (a mantissa and
an exponent, but the exponent is constrained to be a multiple of 3), and SI
notation (a mantissa and a SI scale factor).  You can optionally give an
integer immediately after the display mode to indicate the desired
precision.  For example,
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 10,000
\fB10K\fP: fix2
\fB10,000.00\fP: sci3
\fB1.000e+04\fP: eng2
\fB10.0e+03\fP: si4
\fB10K\fP: 2pi*
\fB62.832K\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Notice that scientific and engineering notations always displays the
specified number of digits whereas SI notation suppresses zeros at the end
of the number.
.sp
When displaying numbers using SI notation, \fBec\fP does not use the
full range of available scale factors under the assumption that the largest
and smallest would be unfamiliar to most people. For this reason, \fBec\fP
only uses the most common scale factors when outputting numbers (T, G, M, K,
m, u, n, p, f, a).
.SH INTEGERS
.sp
You can enter integers in either hexadecimal (base 16), decimal (base 10),
octal (base 8), or binary (base 2). You can use either programmers notation
(leading 0) or Verilog notation (leading \(aq) as shown in the examples below:
.INDENT 0.0
.INDENT 3.5
.TS
center;
|l|l|.
_
T{
0xFF
T}	T{
hexadecimal
T}
_
T{
99
T}	T{
decimal
T}
_
T{
0o77
T}	T{
octal
T}
_
T{
0b1101
T}	T{
binary
T}
_
T{
\(aqhFF
T}	T{
Verilog hexadecimal
T}
_
T{
\(aqd99
T}	T{
Verilog decimal
T}
_
T{
\(aqo77
T}	T{
Verilog octal
T}
_
T{
\(aqb1101
T}	T{
Verilog binary
T}
_
.TE
.UNINDENT
.UNINDENT
.sp
Internally, \fBec\fP represents all numbers as double\-precision real numbers.
To display them as decimal integers, use \fIfix0\fP\&. However, you can display
the numbers in either base 16 (hexadecimal), base 10 (decimal), base 8
(octal) or base 2 (binary)  by setting the display mode.  Use either \fIhex\fP,
\fIfix0\fP, \fIoct\fP, \fIbin\fP, \fIvhex\fP, \fIvdec\fP, \fIvoct\fP, or \fIvbin\fP\&. In each of
these cases the number is rounded to the closest integer before it is
displayed. Add an integer after the display mode to control the number of
digits. For example:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1000
\fB1K\fP: hex
\fB0x3b8\fP: hex8
\fB0x000003b8\fP: hex0
\fB0x3b8\fP: voct
\fB\(aqo1750\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.SH COMPLEX NUMBERS
.sp
\fBec\fP provides limited support for complex numbers. Two imaginary constants
are available that can be used to construct complex numbers, \fIj\fP and
\fIj2pi\fP\&. In addition, two functions are available for converting complex
numbers to real, \fImag\fP returns the magnitude and \fIph\fP returns the phase.
They are unusual in that they do not replace the value in the \fIx\fP register
with the result, instead they simply push either the magnitude of phase into
the \fIx\fP register, which pushes the original complex number into the \fIy\fP
register. For example,
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1 j +
\fB1 + j\fP: mag
\fB1.4142\fP: pop
\fB1 + j\fP: ph
\fB45 degs\fP: stack
.in +2
\fIy\fP: 1 + j
\fIx\fP: 45 degs
.in -2
\fB45 degs\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
You can also add the imaginary unit to real number constants. For example,
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: j10M
\fBj10M\fP: \-j1u *
\fB10\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Only a small number of functions actually support complex numbers; currently
only \fIexp\fP and \fIsqrt\fP\&. However, most of the basic arithmetic operators
support complex numbers.
.SH CONSTANTS
.sp
\fBec\fP provides several useful mathematical and physical constants that are
accessed by specifying them by name. Several of the constants have both MKS
and CGS forms (ec uses ESU\-CGS). You can set which version you want by
setting the desired unit system as follows:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: mks
\fB0\fP: h
\fB662.61e\-36 J\-s\fP: k
\fB13.806e\-24 J/K\fP: cgs
\fB13.806e\-24 J/K\fP: h
\fB6.6261e\-27 erg\-s\fP: k
\fB138.06 aerg/K\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Notice that the unit\-system is sticky, meaning that it remains in force
until explicitly changed. \(aqmks\(aq is the default unit system.
.sp
The physical constants are given in base units (meters, grams, seconds).
For example, the mass of an electron is given in grams rather than kilograms
as would be expected for MKS units.  Similarly, the speed of light is given
in meters per second rather than centimeters per second as would be expected
of CGS units.  This is necessary so that numbers are not displayed with two
scale factors (ex. 1 mkg).  Thus, it may be necessary for you to explicitly
convert to kg (MKS) or cm (CGS) before using values in formulas that are
tailored for one specific unit system.
.sp
The 2014 NIST values are used.  The available constants include:
.INDENT 0.0
.INDENT 3.5
.TS
center;
|l|l|.
_
T{
pi
T}	T{
the ratio of a circle\(aqs circumference to its diameter
T}
_
T{
2pi
T}	T{
the ratio of a circle\(aqs circumference to its radius
T}
_
T{
rt2
T}	T{
square root of two
T}
_
T{
0C
T}	T{
0 Celsius in Kelvin
T}
_
T{
j
T}	T{
imaginary unit (square root of −1)
T}
_
T{
j2pi
T}	T{
j2π
T}
_
T{
k
T}	T{
Boltzmann constant
T}
_
T{
h
T}	T{
Planck constant
T}
_
T{
q
T}	T{
elementary charge (the charge of an electron)
T}
_
T{
c
T}	T{
speed of light in a vacuum
T}
_
T{
eps0
T}	T{
permittivity of free space
T}
_
T{
mu0
T}	T{
permeability of free space
T}
_
T{
Z0
T}	T{
Characteristic impedance of free space
T}
_
T{
hbar
T}	T{
Reduced Planck constant
T}
_
T{
me
T}	T{
rest mass of an electron
T}
_
T{
mp
T}	T{
mass of a proton
T}
_
T{
mn
T}	T{
mass of a neutron
T}
_
T{
mh
T}	T{
mass of a hydrogen atom
T}
_
T{
amu
T}	T{
unified atomic mass unit
T}
_
T{
G
T}	T{
universal gravitational constant
T}
_
T{
g
T}	T{
earth gravity
T}
_
T{
Rinf
T}	T{
Rydberg constant
T}
_
T{
sigma
T}	T{
Stefan\-Boltzmann constant
T}
_
T{
alpha
T}	T{
Fine structure constant
T}
_
T{
R
T}	T{
molar gas constant
T}
_
T{
NA
T}	T{
Avogadro Number
T}
_
T{
rand
T}	T{
random number between 0 and 1
T}
_
.TE
.UNINDENT
.UNINDENT
.sp
As an example of using the predefined constants, consider computing the
thermal voltage, kT/q.
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: k 27 0C + * q/ \(dqV\(dq
\fB25.865 mV\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.SH VARIABLES
.sp
You can store the contents of the \fIx\fP register to a variable by using an
equal sign followed immediately by the name of the variable:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
=«name»
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
where «name» represents the desired name of the variable. It must be
a simple identifer and must be immediately adjacent to the =.
.sp
To recall it, simply use the name:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
«name»
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For example,
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 100MHz =freq
\fB100 MHz\fP: 2pi* \(dqrads/s\(dq =omega
\fB628.32 Mrads/s\fP: 1pF =cin
\fB1 pF\fP: 1 omega cin* /
\fB1.5915K\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
You can display all known variables using \fIvars\fP\&. If you did so immediately
after entering the lines above, you would see:
.INDENT 0.0
.INDENT 3.5
.nf
\fB1.5915K\fP: vars
.in +2
\fIRref\fP: 50 Ohms
\fIcin\fP: 1 pF
\fIfreq\fP: 100 MHz
\fIomega\fP: 628.32 Mrads/s
.in -2
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Choosing a variable name that is the same as a one of a built\-in command or
constant causes the built\-in name to be overridden. Be careful when doing
this as once a built\-in name is overridden it can no longer be accessed.
.sp
Notice that a variable \fIRref\fP exists that you did not create. This is a
predefined variable that is used in dBm calculations. You are free to change
its value if you like.
.SH USER-DEFINED FUNCTIONS
.sp
You can define functions in the following way:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
( ... )«name»
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here \(aq(\(aq starts the function definition and \(aq)«name»\(aq ends it. «name»
represents the desired name of the function. It must be a simple identifer
and must be immediately adjacent to the ).  The \(aq...\(aq represents a sequence
of calculator actions.
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: (2pi * \(dqrads/s\(dq)to_omega
\fB0\fP: (2pi / \(dqHz\(dq)to_freq
\fB0\fP: 100MHz
\fB100 MHz\fP: to_omega
\fB628.32 Mrads/s\fP: to_freq
\fB100 MHz\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The actions entered while defining the function are not evaluated until the
function itself is evaluated.
.sp
Once defined, you can review your function with the \fIvars\fP command. It shows
both the variable and the function definitions:
.INDENT 0.0
.INDENT 3.5
.nf
\fIRref\fP: 50 Ohms
\fIto_freq\fP: (2pi / \(dqHz\(dq)
\fIto_omega\fP: (2pi * \(dqrads/s\(dq)
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The value of the functions are delimited with parentheses.
.SH UNIT CONVERSIONS
.sp
You can perform unit conversions using:
.INDENT 0.0
.INDENT 3.5
>«units»
.UNINDENT
.UNINDENT
.sp
where «units» are the desired units.  «units» must be a simple identifier
though the first character is allowed to be one of a small number of special
characters that typically begin units.  Specifically, $, °, Å, Ƀ, or ș\(ga\(ga.
«units» must be immediately adjacent to the >.  If the value in the \fIx\fP
register has units, the value will be converted to the new units.  If the
value does not have units, its units will be set to «units».
.sp
For example, to convert grams to pounds and back:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 100kg
\fB100 kg\fP: >lbs
\fB220.46 lbs\fP: >g
\fB100 kg\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The following example is a little contrived to show two things.  First,
a value with no units gets assigned the specified units when subject to
a conversion.  Second, several names are known for the same units and the
name assigned to the result is the name specified on the convert command.
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 100
\fB100\fP: >kg
\fB100 kg\fP: >lb
\fB220.46 lb\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Converters are provides for the following units:
.sp
Temperature:
.TS
center;
|l|l|.
_
T{
K:
T}	T{
K, F °F, R °R
T}
_
T{
C °C:
T}	T{
K, C °C, F °F, R °R
T}
_
.TE
.sp
Distance:
.TS
center;
|l|l|.
_
T{
m:
T}	T{
km, m, cm, mm, um μm micron, nm, Å angstrom,
mi mile miles, in inch inches
T}
_
.TE
.sp
Mass/Weight:
.TS
center;
|l|l|.
_
T{
g:
T}	T{
oz, lb lbs
T}
_
.TE
.sp
Time:
.TS
center;
|l|l|.
_
T{
s:
T}	T{
sec second seconds, min minute minutes, hour hours hr, day days
T}
_
.TE
.sp
Bits/Bytes:
.TS
center;
|l|l|.
_
T{
b:
T}	T{
B
T}
_
.TE
.sp
Bitcoin:
.TS
center;
|l|l|.
_
T{
BTC btc Ƀ:
T}	T{
USD usd $, sats sat ș
T}
_
T{
sats sat ș:
T}	T{
USD usd $, BTC btc Ƀ
T}
_
.TE
.sp
The conversions can occur between a pair of units, one from the first column
and one from the second. They do not occur when both units are only in the
second column. So for example, it is possible to convert between \fIg\fP and
\fIlbs\fP, but not between \fIoz\fP and \fIlb\fP\&.  However, if you notice, the units in
the second column are grouped using commas.  A set of units within commas
are considered equivalent, meaning that there are multiple names for the
same underlying unit.  For example, \fIin\fP, \fIinch\fP, and \fIinches\fP are all
considered equivalent. You can convert between equivalent units even though
both are found in the second column.
.sp
Bitcoin conversions are performed by accessing quotes from coingecko.com.
You must have an internet connection for this feature to work.
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1BTC
\fB1 BTC\fP: >$
\fB$46,485.00\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
You can use user\-defined functions to create functions that create units
directly.  For example, here are function definitions for converting bitcoin
and temperatures that you can put in your ~/.ecrc file:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# bitcoin
(>Ƀ    )tb    # convert unitless number to bitcoin
(>Ƀ  >$)btd   # convert bitcoin to dollars
(>Ƀ  >ș)bts   # convert bitcoin to satoshis
(>ș    )ts    # convert unitless number to satoshis
(>ș  >Ƀ)stb   # convert satoshis to bitcoin
(>ș  >Ƀ)stb   # convert satoshis to bitcoin
(>ș  >$)std   # convert bitcoin to dollars
(>$  >Ƀ)dtb   # convert dollars to bitcoin
(>$  >ș)dts   # convert dollars to satoshis

# temperature
(>°C   )tc    # convert unitless number to Celsius
(>°C >K)ctk   # convert Celsius to Kelvin
(>°C >°F)ctf  # convert Celsius to Fahrenheit
(>°F    )tf   # convert unitless number to Fahrenheit
(>°F >K)ftk   # convert Fahrenheit to Kelvin
(>°F >°C)ftc  # convert Fahrenheit to Celsius
(>K  >°C)ktc  # convert Kelvin to Celsius
(>K  >°F)ktf  # convert Kelvin to Fahrenheit
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
With these function, you can convert a simple number (without units)
directly to the desired units:
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1 btd
\fB$46,485.00\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.SH OPERATORS, FUNCTIONS, NUMBERS AND COMMANDS
.sp
In the following descriptions, optional values are given in brackets ([])
and values given in angle brackets (<>) are not to be taken literally (you
are expected to choose a suitable value). For example \(dqfix[<\fIN\fP>]\(dq can
represent \(dqfix\(dq or \(dqfix4\(dq, but not \(dqfixN\(dq.
.sp
For each action that changes the stack a synopsis of those changes is given
in the form of two lists separated by \fB=>\fP\&. The list on the left
represents the stack before the action is applied, and the list on the right
represents the stack after the action was applied. In both of these lists,
the \fIx\fP register is given first (on the left). Those registers that are
involved in the action are listed explicitly, and the rest are represented
by \fB\&...\fP\&. In the before picture, the names of the registers involved in
the action are simply named. In the after picture, the new values of the
registers are described. Those values represented by \fB\&...\fP on the right
side of \fB=>\fP are the same as represented by \fB\&...\fP on the left, though
they may have moved. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... => x+y, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This represents addition. In this case the values in the \fIx\fP and \fIy\fP
registers are summed and placed into the \fIx\fP register. All other values move
to the left one place.
.SS Arithmetic Operators
.sp
\fB+\fP: addition
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the
stack and the sum is placed back on the stack into the \fIx\fP
register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → x+y, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB\-\fP: subtraction
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the
stack and the difference is placed back on the stack into the \fIx\fP
register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → x\-y, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB*\fP: multiplication
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the
stack and the product is placed back on the stack into the \fIx\fP
register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → x*y, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB/\fP: true division
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack and
the quotient is placed back on the stack into the \fIx\fP register.  Both
values are treated as real numbers and the result is a real number. So
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1 2/
\fB500m\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → y/x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB//\fP: floor division
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the
stack, the quotient is computed and then converted to an integer using
the floor operation (it is replaced by the largest integer that is
smaller than the quotient), and that is placed back on the stack into
the \fIx\fP register.  So
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1 2//
\fB0\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → y//x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB%\fP: modulus
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack, the
quotient is computed and the remainder is placed back on the stack into
the \fIx\fP register.  So
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 14 3%
\fB2\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
In this case 2 is the remainder because 3 goes evenly into 14 three
times, which leaves a remainder of 2.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → y%x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBchs\fP: change sign
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its negative.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → −x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBrecip\fP: reciprocal
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its reciprocal.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 1/x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBceil\fP: round towards positive infinity
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its value rounded
towards infinity (replaced with the smallest integer greater than its
value).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → ceil(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBfloor\fP: round towards negative infinity
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its value rounded
towards negative infinity (replaced with the largest integer smaller
than its value).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → floor(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB!\fP: factorial
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with the factorial of its
value rounded to the nearest integer.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → x!, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB%chg\fP: percent change
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack and
the percent difference between \fIx\fP and \fIy\fP relative to \fIy\fP is pushed
back into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → 100*(x\-y)/y, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB||\fP: parallel combination
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack and
replaced with the reciprocal of the sum of their reciprocals.  If the
values in the \fIx\fP and \fIy\fP registers are both resistances, both
elastances, or both inductances, then the result is the resistance,
elastance or inductance of the two in parallel. If the values are
conductances, capacitances or susceptances, then the result is the
conductance, capacitance or susceptance of the two in series.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → 1/(1/x+1/y), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Powers, Roots, Exponentials and Logarithms
.sp
\fB**\fP: raise y to the power of x
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the
stack and replaced with the value of \fIy\fP raised to the power of
\fIx\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → y**x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
aliases: pow,ytox
.UNINDENT
.UNINDENT
.sp
\fBexp\fP: natural exponential
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its exponential.
Supports a complex argument.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → exp(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: powe
.UNINDENT
.UNINDENT
.sp
\fBln\fP: natural logarithm
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its natural logarithm.
Supports a complex argument.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → ln(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: loge
.UNINDENT
.UNINDENT
.sp
\fBpow10\fP: raise 10 to the power of x
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with 10 raised to \fIx\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 10**x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: 10tox
.UNINDENT
.UNINDENT
.sp
\fBlog\fP: base 10 logarithm
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its common logarithm.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → log(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
aliases: log10,lg
.UNINDENT
.UNINDENT
.sp
\fBpow2\fP: raise 2 to the power of x
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with 2 raised to \fIx\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 2**x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: 2tox
.UNINDENT
.UNINDENT
.sp
\fBlog2\fP: base 2 logarithm
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its base 2 logarithm.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → log2(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: lb
.UNINDENT
.UNINDENT
.sp
\fBsqr\fP: square
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its square.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → x**2, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBsqrt\fP: square root
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its square root.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → sqrt(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: rt
.UNINDENT
.UNINDENT
.sp
\fBcbrt\fP: cube root
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its cube root.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → cbrt(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Trigonometric Functions
.sp
\fBsin\fP: trigonometric sine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its sine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → sin(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBcos\fP: trigonometric cosine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its cosine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → cos(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBtan\fP: trigonometric tangent
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its tangent.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → tan(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBasin\fP: trigonometric arc sine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its arc sine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → asin(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBacos\fP: trigonometric arc cosine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its arc cosine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → acos(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBatan\fP: trigonometric arc tangent
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its arc tangent.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → atan(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBrads\fP: use radians
.INDENT 0.0
.INDENT 3.5
Switch the trigonometric mode to radians (functions such as \fIsin\fP,
\fIcos\fP, \fItan\fP, and \fIptor\fP expect angles to be given in radians;
functions such as \fIarg\fP, \fIasin\fP, \fIacos\fP, \fIatan\fP, \fIatan2\fP, and
\fIrtop\fP should produce angles in radians).
.UNINDENT
.UNINDENT
.sp
\fBdegs\fP: use degrees
.INDENT 0.0
.INDENT 3.5
Switch the trigonometric mode to degrees (functions such as \fIsin\fP,
\fIcos\fP, \fItan\fP, and \fIptor\fP expect angles to be given in degrees;
functions such as \fIarg\fP, \fIasin\fP, \fIacos\fP, \fIatan\fP, \fIatan2\fP, and
\fIrtop\fP should produce angles in degrees).
.UNINDENT
.UNINDENT
.SS Complex and Vector Functions
.sp
\fBabs\fP: magnitude of complex number
.INDENT 0.0
.INDENT 3.5
The absolute value of the number in the \fIx\fP register is pushed onto the
stack if it is real. If the value is complex, the magnitude is pushed
onto the stack.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → abs(x), x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: mag
.UNINDENT
.UNINDENT
.sp
\fBarg\fP: phase of complex number
.INDENT 0.0
.INDENT 3.5
The argument of the number in the \fIx\fP register is pushed onto the
stack if it is complex. If the value is real, zero is pushed
onto the stack.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → arg(x), x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: ph
.UNINDENT
.UNINDENT
.sp
\fBhypot\fP: hypotenuse
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack and
replaced with the length of the vector from the origin to the point
(\fIx\fP, \fIy\fP).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → sqrt(x**2+y**2), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: len
.UNINDENT
.UNINDENT
.sp
\fBatan2\fP: two\-argument arc tangent
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack and
replaced with the angle of the vector from the origin to the point.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → atan2(y,x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: angle
.UNINDENT
.UNINDENT
.sp
\fBrtop\fP: convert rectangular to polar coordinates
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack and
replaced with the length of the vector from the origin to the point
(\fIx\fP, \fIy\fP) and with the angle of the vector from the origin to the
point (\fIx\fP, \fIy\fP).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → sqrt(x**2+y**2), atan2(y,x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBptor\fP: convert polar to rectangular coordinates
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are popped from the stack and
interpreted as the length and angle of a vector and are replaced with
the coordinates of the end\-point of that vector.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → x*cos(y), x*sin(y), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Hyperbolic Functions
.sp
\fBsinh\fP: hyperbolic sine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its hyperbolic sine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → sinh(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBcosh\fP: hyperbolic cosine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its hyperbolic cosine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → cosh(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBtanh\fP: hyperbolic tangent
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its hyperbolic tangent.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → tanh(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBasinh\fP: hyperbolic arc sine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its hyperbolic arc sine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → asinh(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBacosh\fP: hyperbolic arc cosine
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its hyperbolic arc
cosine.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → acosh(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBatanh\fP: hyperbolic arc tangent
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its hyperbolic arc
tangent.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → atanh(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Decibel Functions
.sp
\fBdb\fP: convert voltage or current to dB
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is replaced with its value in
decibels. It is appropriate to apply this form when
converting voltage or current to decibels.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 20*log(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
aliases: db20,v2db,i2db
.UNINDENT
.UNINDENT
.sp
\fBadb\fP: convert dB to voltage or current
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is converted from decibels and that value
is placed back into the \fIx\fP register.  It is appropriate to apply this
form when converting decibels to voltage or current.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 10**(x/20), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
aliases: db2v,db2i
.UNINDENT
.UNINDENT
.sp
\fBdb10\fP: convert power to dB
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is converted from decibels and that
value is placed back into the \fIx\fP register.  It is appropriate to
apply this form when converting power to decibels.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 10*log(x), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: p2db
.UNINDENT
.UNINDENT
.sp
\fBadb10\fP: convert dB to power
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is converted from decibels and that value
is placed back into the \fIx\fP register.  It is appropriate to apply this
form when converting decibels to voltage or current.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 10**(x/10), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: db2p
.UNINDENT
.UNINDENT
.sp
\fBvdbm\fP: convert peak voltage to dBm
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is expected to be the peak voltage of a
sinusoid that is driving a load resistor equal to \fIRref\fP (a predefined
variable).  It is replaced with the power delivered to the resistor in
decibels relative to 1 milliwatt.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 30+10*log10((x**2)/(2*Rref)), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: v2dbm
.UNINDENT
.UNINDENT
.sp
\fBdbmv\fP: dBm to peak voltage
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is expected to be a power in decibels
relative to one milliwatt. It is replaced with the peak voltage of a
sinusoid that would be needed to deliver the same power to a load
resistor equal to \fIRref\fP (a predefined variable).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → sqrt(2*10**(x \- 30)/10)*Rref), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: dbm2v
.UNINDENT
.UNINDENT
.sp
\fBidbm\fP: peak current to dBm
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is expected to be the peak current of a
sinusoid that is driving a load resistor equal to \fIRref\fP (a predefined
variable).  It is replaced with the power delivered to the resistor in
decibels relative to 1 milliwatt.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → 30+10*log10(((x**2)*Rref/2), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: i2dbm
.UNINDENT
.UNINDENT
.sp
\fBdbmi\fP: dBm to peak current
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is expected to be a power in decibels
relative to one milliwatt. It is replaced with the peak current of a
sinusoid that would be needed to deliver the same power to a load
resistor equal to \fIRref\fP (a predefined variable).
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → sqrt(2*10**(x \- 30)/10)/Rref), ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: dbm2i
.UNINDENT
.UNINDENT
.SS Constants
.sp
\fBpi\fP: the ratio of a circle\(aqs circumference to its diameter
.INDENT 0.0
.INDENT 3.5
The value of π (3.141592...) is pushed on the stack into the \fIx\fP
register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → π, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: π
.UNINDENT
.UNINDENT
.sp
\fB2pi\fP: the ratio of a circle\(aqs circumference to its radius
.INDENT 0.0
.INDENT 3.5
2π (6.283185...) is pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → 2π, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
aliases: tau,τ,2π
.UNINDENT
.UNINDENT
.sp
\fBrt2\fP: square root of two
.INDENT 0.0
.INDENT 3.5
√2 (1.4142...) is pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → √2, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB0C\fP: 0 Celsius in Kelvin
.INDENT 0.0
.INDENT 3.5
Zero celsius in kelvin (273.15 K) is pushed on the stack into
the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → 0C, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBj\fP: imaginary unit (square root of −1)
.INDENT 0.0
.INDENT 3.5
The imaginary unit (square root of \-1) is pushed on the stack into
the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → j, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBj2pi\fP: j2π
.INDENT 0.0
.INDENT 3.5
2π times the imaginary unit (j6.283185...) is pushed on the stack into
the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → j*2*pi, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
aliases: jtau,jτ,j2π
.UNINDENT
.UNINDENT
.sp
\fBk\fP: Boltzmann constant
.INDENT 0.0
.INDENT 3.5
The Boltzmann constant (R/NA or 1.38064852×10⁻²³ J/K [mks] or
1.38064852×10⁻¹⁶ erg/K [cgs]) is pushed on the stack into the \fIx\fP
register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → k, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBh\fP: Planck constant
.INDENT 0.0
.INDENT 3.5
The Planck constant \fIh\fP (6.626070×10⁻³⁴ J\-s [mks] or 6.626070×10⁻²⁷ erg\-s [cgs])
is pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → h, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBq\fP: elementary charge (the charge of an electron)
.INDENT 0.0
.INDENT 3.5
The elementary charge (the charge of an electron or 1.6021766208×10⁻¹⁹ C
[mks] or 4.80320425×10⁻¹⁰ statC [cgs]) is pushed on the stack into the
\fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → q, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBc\fP: speed of light in a vacuum
.INDENT 0.0
.INDENT 3.5
The speed of light in a vacuum (2.99792458×10⁸ m/s) is pushed on the stack
into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → c, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBeps0\fP: permittivity of free space
.INDENT 0.0
.INDENT 3.5
The permittivity of free space (8.854187817×10⁻¹² F/m [mks] or 1/4π [cgs])
is pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → eps0, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBmu0\fP: permeability of free space
.INDENT 0.0
.INDENT 3.5
The permeability of free space (4π×10⁻⁷ H/m [mks] or 4π/c² s²/m²
[cgs]) is pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → mu0, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBZ0\fP: Characteristic impedance of free space
.INDENT 0.0
.INDENT 3.5
The characteristic impedance of free space (376.730313461 Ω) is
pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → Z0, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBhbar\fP: Reduced Planck constant
.INDENT 0.0
.INDENT 3.5
The reduced Planck constant \fIħ\fP (1.054571800×10⁻³⁴ J\-s [mks] or
1.054571800×10⁻²⁷ erg\-s [cgs]) is pushed on the stack into the \fIx\fP
register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → ħ, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: ħ
.UNINDENT
.UNINDENT
.sp
\fBme\fP: rest mass of an electron
.INDENT 0.0
.INDENT 3.5
The rest mass of an electron (9.10938356×10⁻²⁸ g) is pushed on the stack
into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → me, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBmp\fP: mass of a proton
.INDENT 0.0
.INDENT 3.5
The mass of a proton (1.672621898×10⁻²⁴ g) is pushed on the stack into
the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → mp, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBmn\fP: mass of a neutron
.INDENT 0.0
.INDENT 3.5
The mass of a neutron (1.674927471×10⁻²⁴ g) is pushed on the stack into
the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → mn, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBmh\fP: mass of a hydrogen atom
.INDENT 0.0
.INDENT 3.5
The mass of a hydrogen atom (1.6735328115×10⁻²⁴ g) is pushed on the stack into
the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → mh, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBamu\fP: unified atomic mass unit
.INDENT 0.0
.INDENT 3.5
The unified atomic mass unit (1.660539040×10⁻²⁴ g) is pushed on the stack
into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → amu, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBG\fP: universal gravitational constant
.INDENT 0.0
.INDENT 3.5
The universal gravitational constant (6.6746×10⁻¹⁴ m³/g\-s²) is pushed
on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → G, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBg\fP: earth gravity
.INDENT 0.0
.INDENT 3.5
The standard acceleration at sea level due to gravity on earth (9.80665
m/s²)) is pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → g, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBRinf\fP: Rydberg constant
.INDENT 0.0
.INDENT 3.5
The Rydberg constant (10973731 m⁻¹) is pushed on the stack into the
\fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → Ry, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBsigma\fP: Stefan\-Boltzmann constant
.INDENT 0.0
.INDENT 3.5
The Stefan\-Boltzmann constant (5.670367×10⁻⁸ W/m²K⁴) is pushed on
the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → sigma, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBalpha\fP: Fine structure constant
.INDENT 0.0
.INDENT 3.5
The fine structure  constant (7.2973525664e\-3) is pushed on
the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → alpha, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBR\fP: molar gas constant
.INDENT 0.0
.INDENT 3.5
The molar gas constant (8.3144598 J/mol\-K [mks] or 83.145 Merg/deg\-mol
[cgs]) is pushed on the stack into the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → R, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNA\fP: Avogadro Number
.INDENT 0.0
.INDENT 3.5
Avogadro constant (6.022140857×10²³ mol⁻¹) is pushed on the stack into
the \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → NA, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBmks\fP: use MKS units for constants
.INDENT 0.0
.INDENT 3.5
Switch the unit system for constants to MKS or SI.
.UNINDENT
.UNINDENT
.sp
\fBcgs\fP: use ESU CGS units for constants
.INDENT 0.0
.INDENT 3.5
Switch the unit system for constants to ESU CGS.
.UNINDENT
.UNINDENT
.SS Numbers
.sp
\fB«N[.M][S][U]»\fP: a real number
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is the
integer portion of the mantissa and \fIM\fP is an optional fractional part.
\fIS\fP is a letter that represents an SI scale factor. \fIU\fP the optional
units (must not contain special characters).  For example, 10MHz
represents 10⁷ Hz.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB«N[.M]»e«E[U]»\fP: a real number in scientific notation
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is the
integer portion of the mantissa and \fIM\fP is an optional fractional part.
\fIE\fP is an integer exponent. \fIU\fP the optional units (must not contain
special characters).  For example, 2.2e\-8F represents 22nF.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB0x«N»\fP: a hexadecimal number
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is an
integer in base 16 (use a\-f to represent digits greater than 9).  For
example, 0xFF represents the hexadecimal number FF or the decimal number
255.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB0o«N»\fP: a number in octal
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is an
integer in base 8 (it must not contain the digits 8 or 9).  For example,
0o77 represents the octal number 77 or the decimal number 63.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB0b«N»\fP: a number in binary
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is an
integer in base 2 (it may contain only the digits 0 or 1).  For example,
0b1111 represents the octal number 1111 or the decimal number 15.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB\(aqh«N»\fP: a number in Verilog hexadecimal notation
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is an
integer in base 16 (use a\-f to represent digits greater than 9).  For
example, \(aqhFF represents the hexadecimal number FF or the decimal number
255.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB\(aqd«N»\fP: a number in Verilog decimal
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is an
integer in base 10.  For example, \(aqd99 represents the decimal number 99.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB\(aqo«N»\fP: a number in Verilog octal
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is an
integer in base 8 (it must not contain the digits 8 or 9).  For example,
\(aqo77 represents the octal number 77 or the decimal number 63.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB\(aqb«N»\fP: a number in Verilog binary
.INDENT 0.0
.INDENT 3.5
The number is pushed on the stack into the \fIx\fP register.  \fIN\fP is an
integer in base 2 (it may contain only the digits 0 or 1).  For example,
\(aqb1111 represents the binary number 1111 or the decimal number 15.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → num, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Number Formats
.sp
\fBsi[«N»]\fP: use SI notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed with a fixed number of digits of precision and the
SI scale factors are used to convey the exponent when possible.  If an
optional whole number \fIN\fP immediately follows \fIsi\fP, the precision is
set to \fIN\fP digits.
.UNINDENT
.UNINDENT
.sp
\fBeng[«N»]\fP: use engineering notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed with a fixed number of digits of precision and the
exponent is given explicitly as an integer.  If an optional whole number
\fIN\fP immediately follows \fIsci\fP, the precision is set to \fIN\fP digits.
.sp
Engineering notation differs from scientific notation in that it allows
1, 2 or 3 digits to precede the decimal point in the mantissa and the
exponent is always a multiple of 3.
.UNINDENT
.UNINDENT
.sp
\fBsci[«N»]\fP: use scientific notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed with a fixed number of digits of precision and the
exponent is given explicitly as an integer.  If an optional whole number
\fIN\fP immediately follows \fIsci\fP, the precision is set to \fIN\fP digits.
.sp
Scientific notation differs from engineering notation in that it allows
only 1 digit to precede the decimal point in the mantissa and the
exponent is not constrained to be a multiple of 3.
.UNINDENT
.UNINDENT
.sp
\fBfix[«N»]\fP: use fixed notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed with a fixed number of digits to the right of the
decimal point. If an optional whole number \fIN\fP immediately follows
\fIfix\fP, the number of digits to the right of the decimal point is set to
\fIN\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBhex[«N»]\fP: use hexadecimal notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed in base 16 (a\-f are used to represent digits
greater than 9) with a fixed number of digits.  If an optional whole
number \fIN\fP immediately follows \fIhex\fP, the number of digits displayed
is set to \fIN\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBoct[«N»]\fP: use octal notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed in base 8 with a fixed number of digits.  If an
optional whole number \fIN\fP immediately follows \fIoct\fP, the number of
digits displayed is set to \fIN\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBbin[«N»]\fP: use binary notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed in base 2 with a fixed number of digits.  If an
optional whole number \fIN\fP immediately follows \fIbin\fP, the number of
digits displayed is set to \fIN\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBvhex[«N»]\fP: use Verilog hexadecimal notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed in base 16 in Verilog format (a\-f are used to
represent digits greater than 9) with a fixed number of digits.  If an
optional whole number \fIN\fP immediately follows \fIvhex\fP, the number of
digits displayed is set to \fIN\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBvdec[«N»]\fP: use Verilog decimal notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed in base 10 in Verilog format with a fixed number
of digits.  If an optional whole number \fIN\fP immediately follows
\fIvdec\fP, the number of digits displayed is set to \fIN\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBvoct[«N»]\fP: use Verilog octal notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed in base 8 in Verilog format with a fixed number of
digits.  If an optional whole number \fIN\fP immediately follows \fIvoct\fP,
the number of digits displayed is set to \fIN\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBvbin[«N»]\fP: use Verilog binary notation
.INDENT 0.0
.INDENT 3.5
Numbers are displayed in base 2 in Verilog format with a fixed number of
digits.  If an optional whole number \fIN\fP immediately follows \fIvbin\fP,
the number of digits displayed is set to \fIN\fP\&.
.UNINDENT
.UNINDENT
.SS Variable Commands
.sp
\fB=«name»\fP: store value into a variable
.INDENT 0.0
.INDENT 3.5
Store the value in the \fIx\fP register into a variable with the given
name.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB«name»\fP: recall value of a variable
.INDENT 0.0
.INDENT 3.5
Place the value of the variable with the given name into the \fIx\fP
register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → value of «name», ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBvars\fP: print variables
.INDENT 0.0
.INDENT 3.5
List all defined variables and their values.
.UNINDENT
.UNINDENT
.SS Stack Commands
.sp
\fBswap\fP: swap x and y
.INDENT 0.0
.INDENT 3.5
The values in the \fIx\fP and \fIy\fP registers are swapped.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, y, ... → y, x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBdup\fP: duplicate \fIx\fP
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is pushed onto the stack again.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → x, x, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: enter
.UNINDENT
.UNINDENT
.sp
\fBpop\fP: discard x
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP register is pulled from the stack and discarded.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
alias: clrx
.UNINDENT
.UNINDENT
.sp
\fBlastx\fP: recall previous value of x
.INDENT 0.0
.INDENT 3.5
The previous value of the \fIx\fP register is pushed onto the stack.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → lastx, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBstack\fP: print stack
.INDENT 0.0
.INDENT 3.5
Print all the values stored on the stack.
.UNINDENT
.UNINDENT
.sp
\fBclstack\fP: clear stack
.INDENT 0.0
.INDENT 3.5
Remove all values from the stack.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... →
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Miscellaneous Commands
.sp
\fBrand\fP: random number between 0 and 1
.INDENT 0.0
.INDENT 3.5
A number between 0 and 1 is chosen at random and its value is pushed on
the stack into \fIx\fP register.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&... → rand, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB\(ga«text»\(ga\fP: print text
.INDENT 0.0
.INDENT 3.5
Print \(dqtext\(dq (the contents of the back\-quotes) to the terminal.
Generally used in scripts to report and annotate results.  Any instances
of $N or ${N} are replaced by the value of register N, where 0
represents the \fIx\fP register, 1 represents the \fIy\fP register, etc.  Any
instances of $Var or ${Var} are replaced by the value of the variable
\fIVar\fP\&.
.UNINDENT
.UNINDENT
.sp
\fB\(dq«units»\(dq\fP: set the units of the x register
.INDENT 0.0
.INDENT 3.5
The units given are applied to the value in the \fIx\fP register.
The actual value is unchanged.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → x \(dqunits\(dq, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB>«units»\fP: convert value to given units
.INDENT 0.0
.INDENT 3.5
The value in the \fIx\fP is popped from the stack, converted to the desired
units, and pushed back on to the stack.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
x, ... → x converted to specified units, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fB(...)«name»\fP: a user\-defined function or macro.
.INDENT 0.0
.INDENT 3.5
A function is defined with the name «name» where ... is a list of commands.
When «name» is entered as a command, it is replaced by the list of
commands.
.UNINDENT
.UNINDENT
.sp
\fBquit\fP: quit (:q or ^D also works)
.INDENT 0.0
.INDENT 3.5
alias: :q
.UNINDENT
.UNINDENT
.sp
\fBhelp\fP: print a summary of the available features
.sp
\fB?[«topic»]\fP: detailed help on a particular topic
.INDENT 0.0
.INDENT 3.5
A topic, in the form of a symbol or name, may follow the question mark,
in which case a detailed description will be printed for that topic.
If no topic is given, a list of available topics is listed.
.UNINDENT
.UNINDENT
.sp
\fBabout\fP: print information about this calculator
.SH HELP
.sp
You can use \fIhelp\fP to get a listing of the various features available in EC
along with a short summary of each feature. For more detailed information,
you can use \(aq?\(aq.  If you use \(aq?\(aq alone you will get a list of all available
help topics. If you use \(aq?<\fItopic\fP>\(aq where \fItopic\fP us either a symbol or a
name, you will get a detailed description of that topic.
.SH INITIALIZATION
.sp
At start up \fBec\fP reads and executes commands from files.  It first tries
\(aq~/.ecrc\(aq and runs any commands it contains if it exists.  It then tries
\(aq./.ecrc\(aq if it exists.  Finally it runs the startup file specified on the
command line (with the \fB\-s\fP or \fB\-\-startup\fP option).  It is common to put
your generic preferences in \(aq~/.exrc\(aq.  For example, if your are an
astronomer with a desire for high precision results, you might use:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# initialization file for ec (engineering calculator)
eng6
6.626070e\-27 \(dqerg\-s\(dq =h       # Planck\(aqs constant in CGS units
1.054571800e\-27 \(dqerg\-s\(dq =hbar # Reduced Planck\(aqs constant in CGS units
1.38064852e\-16 \(dqerg/K\(dq =k     # Boltzmann\(aqs constant in CGS units
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This tells \fBec\fP to use 6 digits of resolution and redefines \fIh\fP and \fIhbar\fP
so that they are given in CGS units. The redefining of the names \fIh\fP,
\fIhbar\fP, and \fIk\fP would normally cause \fBec\fP to print a warning, but such
warnings are suppressed when reading initialization files and scripts.
.sp
After all of the startup files have been processed, the stack is cleared.
.sp
A typical initialization script (~/.ecrc) for a circuit designer might be:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Initialize Engineering Calculator
27 \(dqC\(dq =T               # ambient temperature
(k T 0C + * q/ \(dqV\(dq)vt   # thermal voltage
(2pi* \(dqrads/s\(dq)tw       # to omega \- converts Hertz to rads/s
(2pi/ \(dqHz\(dq)tf           # to freq \- converts rads/s to Hertz
.ft P
.fi
.UNINDENT
.UNINDENT
.SH SCRIPTING
.sp
Command line arguments are evaluated as if they were typed into an
interactive session with the exception of filename arguments.  If an
argument corresponds to an existing file, the file treated as a script,
meaning it is is opened its contents are evaluated.  Otherwise, the argument
itself is evaluate (often it needs to be quoted to protect its contents from
being interpreted by the shell). When arguments are given the calculator by
default does not start an interactive session. For example: to compute an RC
time constant you could use:
.INDENT 0.0
.INDENT 3.5
.nf
$ ec 22k 1pF*
22n
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Notice that the * in the above command is interpreted as glob character,
which is generally not what you want, so it is often best to quote the
script:
.INDENT 0.0
.INDENT 3.5
.nf
$ ec \(aq22k 1pF*\(aq
22n
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Only the calculator commands would be quoted in this manner. If you included
a file name on the command line to run a script, it would have to be given
alone.  For example, assume that the file \(aqbw\(aq exists and contains \(aq* 2pi*
recip \(dqHz\(dq\(aq. This is a script that assumes that the value of R and C are
present in the \fIx\fP and \fIy\fP resisters, and then computes the 3dB bandwith of
the corresponding RC filter. You could run the script with:
.INDENT 0.0
.INDENT 3.5
.nf
$ ec \(aq22k 1pF\(aq bw
7.2343 MHz
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Normally \fBec\fP only prints the value of the \fIx\fP register and only as it
exits.  It is possible to get more control of the output using back\-quoted
strings.  For example:
.INDENT 0.0
.INDENT 3.5
.nf
$  ec \(aq\(gaHello world!\(ga\(aq
Hello world!
0
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Whatever is found within back\-quotes is printed to the output. Notice that
the value of the \fIx\fP register is also output, which may not be desired when
you are generating your own output. You can stop the value of the \fIx\fP
register from being printed by finishing with the \fIquit\fP command, which
tells \fBec\fP to exit immediately:
.INDENT 0.0
.INDENT 3.5
.nf
$  ec \(aq\(gaHello world!\(ga quit\(aq
Hello world!
.fi
.sp
.UNINDENT
.UNINDENT
.sp
You can add the values of registers and variables to your print statements.
\fI$N\fP prints out the value of register \fIN\fP, where 0 is the \fIx\fP register,
1 is the \fIy\fP register, etc. \fI$name\fP will print the value of a variable
with the given name. Alternatively, you can use \fI${N\fP} and \fI${name\fP} to
disambiguate the name or number. To print a dollar sign, use \fI$$\fP\&.  To
print a newline or a tab, use \fI\en\fP and \fI\et\fP\&. For example,
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 100MHz =freq
\fB100 MHz\fP: 2pi* \(dqrads/s\(dq
\fB628.32 Mrads/s\fP: \(ga$freq corresponds to $0.\(ga
100 MHz corresponds to 628.32 Mrads/s.
\fB628.32 Mrads/s\fP:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
To illustrate its use in a script, assume that a file named \fIlg\fP exists and
contains a calculation for the loop gain of a PLL:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# computes and displays loop gain of a frequency synthesizer
# x register is taken to be frequency
=freq
88.3u \(dqV/per\(dq =Kdet  # gain of phase detector
9.07G \(dqHz/V\(dq =Kvco   # gain of voltage controlled oscillator
2 =M                 # divide ratio of divider at output of VCO
8 =N                 # divide ratio of main divider
2 =F                 # divide ratio of prescalar
freq 2pi* \(dqrads/s\(dq =omega
Kdet Kvco* omega/ M/ =a
N F* =f
a f* =T
\e\(gaOpen loop gain = $a\e\enFeedback factor = $f\e\enLoop gain = $T\e\(ga
quit
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When reading scripts from a file, the \(aq#\(aq character introduces a comment. It
and anything that follows is ignored until the end of the line.
.sp
Notice that the script starts by saving the value in the \fIx\fP register to the
variable \fIfreq\fP\&. This script would be run as:
.INDENT 0.0
.INDENT 3.5
.nf
$ ec 1KHz lg
Open loop gain = 63.732
Feedback factor = 16
Loop gain = 1.0197K
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The first argument does not correspond to a file, so it is executed as a
script.  It simply pushes 1KHz onto the stack. The second argument does
correspond to a file, so its contents are executed. The script ends with a
print command, so the results are printed to standard output as the script
terminates.
.sp
One issue with command line scripting that you need to be careful of is that
if an argument is a number with a leading minus sign it will be mistaken to
be a command line option. To avoid this issue, specify the number without
the minus sign and follow it with \fIchs\fP\&.  Alternatively, you can embed the
number in quotes but add a leading space.  For example,
.INDENT 0.0
.INDENT 3.5
.nf
$ ec \-30 dbmv
ec: \-30 dbmv: unknown option.
$ ec 30 chs dbmv
10 mV
$ ec \(aq \-30\(aq dbmv
10 mV
.fi
.sp
.UNINDENT
.UNINDENT
.SH INITIALIZATION SCRIPTS
.sp
You can use scripts to preload in a set of useful constants and function
that can then be used in interactive calculations. To do so, use the \fB\-i\fP
or \fI\-\-interactive\fP command line option. For example, replace the earlier
\(aqlg\(aq script with the following:
.INDENT 0.0
.INDENT 3.5
.nf
88.3u \(dqV/per\(dq =Kdet
9.07G \(dqHz/V\(dq =Kvco
2 =M
8 =N
2 =F
(N F* recip)f
(2pi * Kdet * Kvco* M*)a
(a f*)T
clstack
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Now run:
.INDENT 0.0
.INDENT 3.5
.nf
$ ec \-i lg
0: 1kHz T
629.01M:
.fi
.sp
.UNINDENT
.UNINDENT
.sp
Doing so runs lg, which loads values into the various variables, and then
they can be accessed in further calculations.
.sp
Notice that the script ends with \fIclstack\fP so that you start fresh in your
interactive session. It simply clears the stack so that the only effect of
the script is to initialize the variables.  Using \fB\-s\fP or \fB\-\-startup\fP
does this for you automatically.
.sp
Alternatively, you can put the constants you wish to predeclare in
\fI\&./.ecrc\fP, in which case they are automatically loaded whenever you invoke
\fBec\fP in the directory that contains the file.  Similarly, placing
constants in \fI~/.ecrc\fP causes them to be declared for every invocation of
\fBec\fP\&.
.SH DIAGNOSTICS
.sp
If an error occurs on a line, an error message is printed and the stack is
restored to the values it had before the line was entered. So it is almost
as if you never typed the line in at all.  The exception being that any
variables or modes that are set on the line before the error occurred are
retained.  For example,
.INDENT 0.0
.INDENT 3.5
.nf
\fB0\fP: 1KOhms =r
\fB1 KOhms\fP: 100MHz =freq 1pF = c
=: unrecognized
\fB1 KOhms\fP: stack
.in +2
\fIx\fP: 1 KOhms
.in -2
\fB1 KOhms\fP: vars
.in +2
\fIRref\fP: 50 Ohms
\fIfreq\fP: 100MHz
\fIr\fP: 1 KOhms
.in -2
.fi
.sp
.UNINDENT
.UNINDENT
.sp
The error occurred when trying to assign a value to \fIc\fP because a space was
accidentally left between the equal sign and the variable name.  Notice that
100MHz was saved to the variable \fIfreq\fP, but the stack was restored to the
state it had before the offending line was entered.
.SH SEE ALSO
.sp
bc, dc
.SH AUTHOR
Ken Kundert <ec@nurdletech.com>
.\" Generated by docutils manpage writer.
.
